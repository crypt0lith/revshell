__all__ = ['bash', 'zsh']

import os
import os.path as osp
import re
import sys
from functools import lru_cache, reduce
from shlex import quote
from typing import Callable

from .__main__ import _REVSHELL_FORMATTERS

type CompgenFunc = Callable[[], str]
_COMPGEN_PATHS: dict[CompgenFunc, str] = {}
_WATERMARK_RE = re.compile(rb'# autogenerated by \w+(?:\.\w+)* with Python \d+\.\d+')


def map_reduce[_T, _R](
    __func: Callable[[_T], _R], initial: _T, *funcs: Callable[[_R], _R]
) -> _R:
    return reduce(lambda x, f: f(x), [__func, *funcs], initial)


def _compgen_path[AnyStr: (str, bytes)](__fp: os.PathLike[AnyStr] | AnyStr):
    fp = map_reduce(os.fsdecode, __fp, osp.expanduser, osp.abspath)

    def decorator[F: CompgenFunc](__f: F) -> F:
        _COMPGEN_PATHS[__f] = fp
        return __f

    return decorator


@lru_cache(maxsize=1)
def _get_watermark():
    from . import __name__ as pkg

    prog = osp.splitext(osp.basename(__file__))[0]
    major, minor, *_ = sys.version_info
    return f"# autogenerated by {pkg}.{prog} with Python {major}.{minor}"


def _prepend_watermark(__s: str):
    return '\n'.join([_get_watermark()] + __s.splitlines())


@_compgen_path('~/.local/share/bash-completion/completions/revshell')
def bash():
    src = """\
_revshell() {
\tlocal cur="${COMP_WORDS[COMP_CWORD]}"
\tCOMPREPLY=()
\tif (( COMP_CWORD == 1 )); then
\t\tCOMPREPLY=( $(compgen -W %s -- "$cur") )
\telse
\t\tCOMPREPLY=( $(compgen -f -- "$cur") )
\tfi
}
complete -F _revshell revshell
"""
    src %= quote(' '.join(map(quote, sorted(_REVSHELL_FORMATTERS))))
    return src.expandtabs(4)


@_compgen_path('~/.local/share/zsh/site-functions/_revshell')
def zsh():
    src = """\
#compdef revshell
_revshell_payload() {
\tlocal -a _revshell_payloads
\t_revshell_payloads=(\n%s\n\t)
\t_describe -t payloads 'target payload' _revshell_payloads
}
_revshell() {
\t_arguments -C \\
\t\t'1:target payload:_revshell_payload' \\
\t\t'2:listener addr[IPv4 address / network interface]:_net_interfaces' \\
\t\t'3:listener port:(( 4444 1337 5555 8080 31337 ))'
}
compdef _revshell revshell
"""
    src %= '\n'.join(
        '\t' + quote(f'{k}:{(fn.__doc__ or '\n').splitlines()[0]}')
        for k, fn in sorted(_REVSHELL_FORMATTERS.items(), key=lambda x: x[0])
    )
    return src.expandtabs(4)


def _compgen(__f: CompgenFunc, *, reverse=False, dry_run=False):
    fp = _COMPGEN_PATHS[__f]
    if reverse:
        if osp.exists(fp):
            with open(fp, 'rb') as f:
                header = next(f, None)

            if header and _WATERMARK_RE.fullmatch(header.strip()):
                if dry_run:
                    return print(
                        f'would remove completions file {fp!r}', file=sys.stderr
                    )
                return os.remove(fp)
            reason = 'file exists but does not appear to originate from this program'
        else:
            reason = 'file does not exist'
        if dry_run:
            return print(f'would ignore {fp!r} ({reason})', file=sys.stderr)
    elif dry_run:
        return print(
            f'would write {len(__f().encode())} bytes to {fp!r}', file=sys.stderr
        )
    else:
        os.makedirs(osp.dirname(fp), exist_ok=True)
        with open(fp, 'w') as f:
            f.write(_prepend_watermark(__f()))


def main():
    import argparse

    name2fn = {f.__name__: f for f in _COMPGEN_PATHS}
    valid_names = sorted(name2fn)
    parser = argparse.ArgumentParser()
    parser.add_argument(
        dest='shell_names',
        choices=valid_names,
        action='extend',
        nargs='*',
        metavar='SHELL',
        help=f'one or more shells to generate completions for. available shells: {valid_names!r}',
    )
    parser.add_argument(
        '--all',
        dest='shell_names',
        action='store_const',
        const=valid_names,
        help='generate completions for all currently available shells',
    )
    parser.add_argument(
        '-d',
        '--dry-run',
        dest='dry_run',
        action='store_true',
        help='only display what would happen',
    )
    setup = parser.add_argument_group('setup type')
    setup.add_argument(
        '--reverse', action='store_true', help='undo previously generated completions'
    )
    parsed_args = vars(parser.parse_args())
    shell_names = parsed_args.pop('shell_names') or ['bash']
    shell_names = sorted(set(shell_names), key=shell_names.index)
    for shell_name in shell_names:
        _compgen(name2fn[shell_name], **parsed_args)


if __name__ == '__main__':
    sys.exit(main())
